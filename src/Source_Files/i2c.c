/***************************************************************************//**
 * @file
 *   i2c.c
 * @author
 *   Frank McDermott
 * @date
 *   10/11/2022
 * @brief
 *   I2C source file for use with the Si7021 Temperature & Humidity Sensor
 ******************************************************************************/

//***********************************************************************************
// included header file
//***********************************************************************************
#include "i2c.h"


//***********************************************************************************
// static/private data
//***********************************************************************************


//***********************************************************************************
// static/private functions
//***********************************************************************************
static void i2c_bus_reset(I2C_TypeDef *i2c);


//***********************************************************************************
// function definitions
//***********************************************************************************
/***************************************************************************//**
 * @brief
 *  Resets the I2C Bus [NOT YET IN USE]
 *
 * @details
 *  A reset is achieved by aborting any current operations on the I2C bus to
 *  for the bus to go idle, saving the state of the IEN register, disabling
 *  all interrupts, clearing all interrupt flags, clearing the transmit
 *  buffer and MSTOP bit, sending a START and STOP command, and finally
 *  restoring the state of the IEN register.
 *
 * @param[in] i2c
 *  Desired I2Cn peripheral (either I2C0 or I2C1)
 ******************************************************************************/
// TODO: use in I2C state machine, not yet developed
void i2c_bus_reset(I2C_TypeDef *i2c)
{
  // local variable to save the state of the IEN register
  uint32_t ien_state;

  // abort current transmission to make bus go idle (TRM 16.5.2)
  i2c->CMD = I2C_CMD_ABORT;

  // save state of IEN register
  ien_state = i2c->IEN;

  // disable all interrupts (16.5.17)
  i2c->IEN = _I2C_IEN_RESETVALUE;

  // clear IFC register (TRM 16.5.16)
  i2c->IFC = _I2C_IFC_MASK;

  // assert that IF register is clear
  EFM_ASSERT(!(i2c->IF & _I2C_IEN_RESETVALUE));

  // clear the transmit buffer (16.5.2)
  i2c->CMD = I2C_CMD_CLEARTX;

  // clear MSTOP bit prior to bus reset
  i2c->IFC |= I2C_IFC_MSTOP;

  // bus reset (TRM 16.3.12.2)
  i2c->CMD = I2C_CMD_START | I2C_CMD_STOP;

  // ensure reset occurred properly
  while(!(i2c->IF & I2C_IF_MSTOP));

  // clear IFC register (TRM 16.5.16)
  // clear any bits that may have been generated by START/STOP
  i2c->IFC = _I2C_IFC_MASK;

  // reset I2C peripheral by setting ABORT bit in CMD register
  i2c->CMD = I2C_CMD_ABORT;

  // restore IEN register
  i2c->IEN = ien_state;
}


/***************************************************************************//**
 * @brief
 *  Opens the I2C peripheral.
 *
 * @details
 *  Enables the proper I2Cn CMU clock, sets the START bit, initializes
 *  I2C, and routes & enables the I2C to the proper pin.
 *
 * @param[in] i2c
 *  Desired I2Cn peripheral (either I2C0 or I2C1)
 *
 * @param[in] app_i2c_open
 *  All data required to open the I2C peripheral encapsulated in struct
 ******************************************************************************/
void i2c_open(I2C_TypeDef *i2c, I2C_OPEN_STRUCT *app_i2c_open)
{
  // instantiate a local I2C_Init struct
  I2C_Init_TypeDef i2c_init_values;

  // if the address of i2c is equal to the base address of the
  // I2C0 base peripheral ...
  if(i2c == I2C0)
  {
      // ... enable I2C0 clock
      CMU_ClockEnable(cmuClock_I2C0, true);
  }

  // if the address of i2c is equal to the base address of the
  // I2C1 base peripheral ...
  if(i2c == I2C1)
  {
      // ... enable I2C1 clock
      CMU_ClockEnable(cmuClock_I2C1, true);
  }


  // if START interrupt flag not set ...
  if(!(i2c->IF & I2C_IFS_START))
  {
      // .. set the START interrupt flag
      i2c->IFS = I2C_IFS_START;

      // assert that the flag has been set
      EFM_ASSERT(i2c->IF & I2C_IFS_START);
  }
  // .. else ...
  else
  {
      // clear START flag
      i2c->IFC = I2C_IFC_START;

      // assert that the flag as been cleared
      EFM_ASSERT(!(i2c->IF & I2C_IFS_START));
  }

  // set values for I2C_Init
  i2c_init_values.enable = app_i2c_open->enable;
  i2c_init_values.master = app_i2c_open->master;
  i2c_init_values.freq = app_i2c_open->freq;
  i2c_init_values.refFreq = app_i2c_open->refFreq;
  i2c_init_values.clhr = app_i2c_open->clhr;

  // initialize I2C peripheral
  I2C_Init(i2c, &i2c_init_values);

  // set route location for SDA and SCL
  i2c->ROUTELOC0 |= app_i2c_open->sda_loc0;
  i2c->ROUTELOC0 |= app_i2c_open->scl_loc0;

  // enable pin route
  i2c->ROUTEPEN |= app_i2c_open->sda_pen;
  i2c->ROUTEPEN |= app_i2c_open->scl_pen;
}
